module mult_accum(clk, a, x, out);
        parameter MAT_SCALE = #k#, INPUT_WIDTH = #b#, OUTPUT_WIDTH = INPUT_WIDTH*2;
        input reset, clk;
        input signed [MAT_SCALE - 1:0][INPUT_WIDTH - 1:0] a, x, product_out;
        output signed [OUTPUT_WIDTH - 1:0] pp_out;
        logic [OUTPUT_WIDTH - 1:0] out;

        generate

		my_reg #(OUTPUT_WIDTH) reg_product(.clk(clk), .d(product_out), .reset(reset), .enable(1'b1), .q(add1));
                my_reg #(OUTPUT_WIDTH) reg_out (.clk(clk), .d(pp_out), .reset(reset), .enable(1'b1), .q(out));
        
                //make combinatoral logic in-between
                always_comb begin
                        product_out = a*b;
                        pp_out = out + add1;
                end

        endgenerate

endmodule

module my_reg(clk, d, reset, enable, q);
 parameter REG_WIDTH = 2*#b#;
 input [N-1:0] d;
 input reset, enable, clk;
 output logic [N-1:0] q;

        always_ff @(posedge clk) begin
                if(reset == 1) begin
                        q <= 0;
                end
                else if (enable == 1) begin
                        q <= d;
                end
                else begin
                        q <= q;
                end
        end
endmodule


