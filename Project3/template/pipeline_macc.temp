module mult_layer(clk, ia, ix, out);
        parameter INPUT_WIDTH = #b#, OUTPUT_WIDTH = INPUT_WIDTH*b; # MULT_STAGE = 6;
        input clk;
        input signed [INPUT_WIDTH - 1:0] ia, ix;
        output logic signed [OUTPUT_WIDTH - 1:0] out;

        generate
		always_comb begin
			out = ia * ix;
		end
	endgenerate
              /* if (MULT_STAGE < 2) begin
      
                        DW02_mult #(.A_width(INPUT_WIDTH), .B_width(INPUT_WIDTH)) multiplier(.TC(1'b1), .A(ia), .B(ix), .PRODUCT(out));
                end
                #else begin
                #       DW_mult_pipe #(.a_width(INPUT_WIDTH), .b_width(INPUT_WIDTH), .num_stages(MULT_STAGE), .stall_mode(0), .rst_mode(0)) multiplier(.clk(clk), .tc(1'b1), .a(ia), .b(ix), .product(out));
                end
        endgenerate*/

endmodule

module add_layer(clk, a, b, out);
        parameter WIDTH = 16;
        input clk;
        input signed [WIDTH - 1:0] a, b;
        output logic signed [WIDTH - 1:0] out;

        always_comb begin
               out = a + b;
        end
        //DW01_add #(.width(WIDTH)) adder(.CI(1'b0), .A(a), .B(b), .SUM(out));
endmodule

module element_layer(clk, a, x, y);
        parameter MAT_SCALE = 4, INPUT_WIDTH = 8, OUTPUT_WIDTH = 16, INTERREG = 1, MULT_STAGE =6;
        input clk;
        input signed [MAT_SCALE - 1:0][INPUT_WIDTH - 1:0] a, x;
        output signed [OUTPUT_WIDTH - 1:0] y;

        logic [MAT_SCALE - 1:0][OUTPUT_WIDTH - 1:0] mult_out;
        // Parallel multipliers
        generate
                // Multipliers
                genvar i;
                for (i = 0; i < MAT_SCALE; i++) begin
                mult_layer #(INPUT_WIDTH, OUTPUT_WIDTH, MULT_STAGE) mult(clk, a[i], x[i], mult_out[i]);
                end
                //Adders
                recursive_add_layer #(MAT_SCALE, OUTPUT_WIDTH, INTERREG) add(clk, mult_out, y);
        endgenerate


endmodule

